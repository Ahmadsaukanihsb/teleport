local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local TextChatService = game:GetService("TextChatService")

-- ======= CONFIGURATION =======
local REDIS_API_URL = "https://api-beta-mocha-45.vercel.app/api"
local PLACE_ID = 1234567890  -- Replace with your game ID
local CHECK_INTERVAL = 15    -- Seconds between checks
local INSTANCE_TIMEOUT = 300 -- 5 minutes in seconds
-- =============================

-- Improved HTTP request function
local function makeHttpRequest(method, endpoint, body)
    local requestFunc = syn and syn.request or http_request or request
    if not requestFunc then return nil end
    
    local url = REDIS_API_URL .. endpoint
    local requestData = {
        Url = url,
        Method = method,
        Headers = {
            ["Content-Type"] = "application/json"
        }
    }
    
    if body then
        requestData.Body = HttpService:JSONEncode(body)
    end
    
    local success, response = pcall(requestFunc, requestData)
    return success and response or nil
end

-- Function to manage instance in Redis
local function manageInstance(action, instanceId)
    local endpoint = action == "get" and "/getInstanceId" or "/removeInstance"
    local response = makeHttpRequest(action == "get" and "GET" or "POST", endpoint, 
                      action == "remove" and {instanceId = instanceId} or nil)
    
    if response and response.StatusCode == 200 then
        local data = HttpService:JSONDecode(response.Body)
        return data.instanceId or data.success
    end
    return nil
end

-- Universal chat message function
local function sendChatMessage(message)
    if TextChatService and TextChatService.TextChannels then
        local channel = TextChatService.TextChannels.RBXGeneral
        if channel then
            pcall(function() channel:SendAsync(message) end)
            return
        end
    end
    
    -- Fallback for older chat system
    local chatEvents = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
    if chatEvents then
        local sayMessage = chatEvents:FindFirstChild("SayMessageRequest")
        if sayMessage then
            pcall(function() sayMessage:FireServer(message, "All") end)
        end
    end
end

-- Main monitoring function
local function monitorInstances()
    local lastCheckTime = os.time()
    
    while true do
        -- Clean up old instances periodically
        if os.time() - lastCheckTime > 60 then  -- Every minute
            pcall(function()
                makeHttpRequest("POST", "/cleanupInstances", {timeout = INSTANCE_TIMEOUT})
            end)
            lastCheckTime = os.time()
        end

        -- Get current instance
        local currentInstanceId = game.JobId
        local newInstanceId = manageInstance("get")
        
        if newInstanceId then
            if newInstanceId == currentInstanceId then
                sendChatMessage("Hello Guys!")
                print("Already in the correct instance")
            else
                print("Found new instance, attempting to teleport...")
                local success = pcall(function()
                    TeleportService:TeleportToPlaceInstance(PLACE_ID, newInstanceId, Players.LocalPlayer)
                end)
                
                if success then
                    -- Verify teleport success
                    local startTime = os.time()
                    while os.time() - startTime < 30 do
                        if game.JobId == newInstanceId then
                            sendChatMessage("Hello Guys!")
                            manageInstance("remove", newInstanceId)
                            break
                        end
                        task.wait(1)
                    end
                end
            end
        else
            print("No new instances available")
        end
        
        task.wait(CHECK_INTERVAL)
    end
end

-- Start with error handling
local function startMonitoring()
    while true do
        local success, err = pcall(monitorInstances)
        if not success then
            warn("Monitoring error:", err)
            print("Restarting monitor in 30 seconds...")
            task.wait(30)
        end
    end
end

-- Begin execution
startMonitoring()
