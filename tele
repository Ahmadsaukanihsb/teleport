local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local TextChatService = game:GetService("TextChatService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- ======= CONFIGURATION =======
local REDIS_API_URL = "https://api-beta-mocha-45.vercel.app/api"
local PLACE_ID = 126884695634066  -- Replace with your game ID
local CHECK_INTERVAL = 15    -- Seconds between checks
local INSTANCE_TIMEOUT = 120 -- 2 minutes in seconds
local CHAT_MESSAGE = "dsadadsadas"  -- Message to send when in correct instance
-- =============================

-- Improved HTTP request function
local function makeHttpRequest(method, endpoint, body)
    local requestFunc = syn and syn.request or http_request or request
    if not requestFunc then return nil end
    
    local url = REDIS_API_URL .. endpoint
    local requestData = {
        Url = url,
        Method = method,
        Headers = {
            ["Content-Type"] = "application/json"
        }
    }
    
    if body then
        requestData.Body = HttpService:JSONEncode(body)
    end
    
    local success, response = pcall(requestFunc, requestData)
    return success and response or nil
end

-- Function to get current active instance
local function getCurrentInstance()
    local response = makeHttpRequest("GET", "/getInstanceId")
    if response and response.StatusCode == 200 then
        local data = HttpService:JSONDecode(response.Body)
        return data.instanceId
    end
    return nil
end

-- Universal chat message function
local function sendChatMessage(message)
    -- Try new TextChatService first
    if TextChatService and TextChatService.TextChannels then
        local channel = TextChatService.TextChannels.RBXGeneral
        if channel then
            pcall(function() channel:SendAsync(message) end)
            return
        end
    end
    
    -- Fallback to legacy chat system
    local chatEvents = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
    if chatEvents then
        local sayMessage = chatEvents:FindFirstChild("SayMessageRequest")
        if sayMessage then
            pcall(function() sayMessage:FireServer(message, "All") end)
        end
    end
end

-- Enhanced function to find and click an Accept button
local function clickAcceptButton()
    -- Wait for the GUI to load if needed
    task.wait(1)
    
    local gui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
    if not gui then
        print("No PlayerGui found")
        return false
    end

    -- List of possible button names to look for (case insensitive)
    local targetNames = {
        "accept", "acceptbtn", "btnaccept", "buttonaccept", 
        "join", "joinbtn", "btnjoin", "buttonjoin",
        "confirm", "confirmbtn", "btnconfirm", "buttonconfirm"
    }

    local foundButton = nil

    -- Search through all enabled ScreenGuis
    for _, screen in ipairs(gui:GetChildren()) do
        if screen:IsA("ScreenGui") and screen.Enabled then
            -- Search through all descendants
            for _, descendant in ipairs(screen:GetDescendants()) do
                if (descendant:IsA("TextButton") or (descendant:IsA("ImageButton")) then
                    -- Check if button name matches any target
                    local lowerName = string.lower(descendant.Name)
                    for _, target in ipairs(targetNames) do
                        if string.find(lowerName, target) then
                            -- Additional check for visible/active button
                            if descendant.Visible and descendant.Active then
                                foundButton = descendant
                                break
                            end
                        end
                    end
                    if foundButton then break end
                end
            end
            if foundButton then break end
        end
    end

    if not foundButton then
        print("No accept button found after searching")
        return false
    end

    print("Found button:", foundButton:GetFullName())

    -- Try different methods to click the button
    local success = false

    -- Method 1: Fire the button's MouseButton1Click event if available
    if not success then
        local clickEvent = foundButton:FindFirstChild("MouseButton1Click")
        if clickEvent then
            pcall(function()
                clickEvent:Fire()
                success = true
                print("Clicked via MouseButton1Click event")
            end)
        end
    end

    -- Method 2: Fire the button's Activated event if available
    if not success then
        local activatedEvent = foundButton:FindFirstChild("Activated")
        if activatedEvent then
            pcall(function()
                activatedEvent:Fire()
                success = true
                print("Clicked via Activated event")
            end)
        end
    end

    -- Method 3: Simulate mouse click (fallback)
    if not success then
        pcall(function()
            -- Wait for the button to be ready
            local startTime = os.clock()
            while os.clock() - startTime < 2 do
                if foundButton.AbsoluteSize ~= Vector2.new(0, 0) then
                    break
                end
                task.wait()
            end

            local absolutePosition = foundButton.AbsolutePosition
            local absoluteSize = foundButton.AbsoluteSize
            local center = absolutePosition + absoluteSize / 2

            -- Multiple click attempts
            for i = 1, 3 do
                UserInputService:SendMouseButtonEvent(
                    center.X, center.Y, 0, true, game, 1
                )
                task.wait(0.1)
                UserInputService:SendMouseButtonEvent(
                    center.X, center.Y, 0, false, game, 1
                )
                task.wait(0.5)
                
                -- Check if click was successful (you might need game-specific checks here)
                if not foundButton.Visible then
                    success = true
                    break
                end
            end
            print("Attempted simulated mouse click")
        end)
    end

    return success
end

-- Function to handle instance joining logic
local function handleInstance(newInstanceId)
    local currentInstanceId = game.JobId
    
    if newInstanceId == currentInstanceId then
        -- If already in the correct instance
        sendChatMessage(CHAT_MESSAGE)
        print("Already in the correct instance, searching for Accept button...")
        
        -- Try to find and click an Accept button with retries
        local attempts = 0
        local maxAttempts = 3
        local clicked = false
        
        while attempts < maxAttempts and not clicked do
            attempts += 1
            print(string.format("Attempt %d/%d to find Accept button", attempts, maxAttempts))
            clicked = clickAcceptButton()
            if not clicked then
                task.wait(1) -- Wait before retrying
            end
        end
        
        if clicked then
            print("Successfully clicked Accept button!")
        else
            print("Failed to find/click Accept button after", maxAttempts, "attempts")
        end
        
        return false  -- Indicate we should keep waiting
    else
        -- If new instance found, attempt to join
        print("Found new instance, attempting to teleport...")
        local success = pcall(function()
            TeleportService:TeleportToPlaceInstance(PLACE_ID, newInstanceId, Players.LocalPlayer)
        end)
        
        if success then
            -- Verify teleport success
            local startTime = os.time()
            while os.time() - startTime < 30 do
                if game.JobId == newInstanceId then
                    sendChatMessage(CHAT_MESSAGE)
                    return true  -- Successfully joined new instance
                end
                task.wait(1)
            end
            warn("Timeout: Failed to verify join")
        else
            warn("Teleport failed")
        end
        return false  -- Teleport failed
    end
end

-- Main monitoring loop
local function mainLoop()
    local lastCleanupTime = os.time()
    
    while true do
        -- Clean up old instances periodically
        if os.time() - lastCleanupTime > 60 then
            pcall(function()
                makeHttpRequest("POST", "/cleanupInstances", {timeout = INSTANCE_TIMEOUT})
            end)
            lastCleanupTime = os.time()
        end

        -- Check for new instance
        local newInstanceId = getCurrentInstance()
        
        if newInstanceId then
            handleInstance(newInstanceId)
        else
            print("No new instances available, waiting...")
        end
        
        task.wait(CHECK_INTERVAL)
    end
end

-- Start with error recovery
local function startWithRetry()
    while true do
        local success, err = pcall(mainLoop)
        if not success then
            warn("Main loop error:", err)
            print("Restarting in 30 seconds...")
            task.wait(30)
        end
    end
end

-- Begin execution
startWithRetry()
